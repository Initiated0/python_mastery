# -*- coding: utf-8 -*-
"""Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XdenG309sycxZhpRCuPzGYV7rpVlIHHi

# ***Basics of Python from CodeWithMosh***
"""

# press Ctrl + m + l to get line numbers in colab 

int_var = 32554222
float_var = 3.14156
string1 = "Roll the Dice & Pay the price"
boolval = True #boolean value always starts with Captial e.g.: True/False
message = """
boobs on the bus go up and down
up and down up and down
boob on the bus go up and down
all through the town 
"""

"""# ***Strings***"""

print(message)
#string as object
print(len(string1))
print(string1[:])
print(string1[0:14])
print("let's see what happens: ",string1[:len(string1) - 5])
print(string1[-1])
print(string1[0:-1],string1[-1])

#formatted strings
first = "Nayeem"
last = "Mohammad"

print(f"{first} {last} = {len(first)} + {len(last)} = {len(first+last)}")

#string methods

print("Upper: " , string1.upper())
print("Lower: " , string1.lower())
print("Title: " , string1.lower().title()) #title capitalizes the first letters
print("find: " , string1.find("Pay"))
print("find: ",string1.find("pay")) #will return -1 because pay with lowercase p doesn't exits
print("replace: ",string1.replace("Dice", "Ass")) #will return -1 because pay with lowercase p doesn't exits
print("cum" in string1)
print("cum" in string1.replace("price", "cum"))

"""#***Numbers***#"""

print(32 + 8)
print(32 - 8)
print(32 * 8)
print(32 / 8)
print(32 // 8) # leaves out values after the decimal point
print(32 % 8)
print(32 ** 8)

x = 2
print(x)
x += 100
print(x)
x -= 2
print(x)
x *= 2
print(x)
x /= 2
print(x)
x //= 2
print(x)
x %= 2
print(x)
x **= 2
print(x)

import math # this module has almost all the necessary math functions that you could possibly need
print(math.comb(5, 3))

x = [1,2,3,4,5,6,7,8,9,10]
math.prod(x, start=1)

"""# ***Type Conversion***"""

x = input("x: ")

# x is already in string
print(type(x))

# x += 2 # this throws an error
print("x is: ", x)

#type conversions
# int(x)
# float(x)
# bool(x)
# str(x)

x = int(x) + 9
print("x is: ", x)

# falsy values in python
# ""
# 0
# None
# everything else is True

print(bool("0"))
print(bool("1"))
print(bool("-1"))
print(bool(0))
print(bool(1))
print(bool(-1))
print(bool(True))
print(bool("True"))
print(bool(False))
print(bool("False"))
print(bool(""))

"""# ***Control Flow***

"""

print(1 >= 0) # True
print(1 <= 0) # False
print(10 == 20) # False
print(10 == 10) # True
print(10 == "10") # False
print(10 == int("10")) # True
print(10 == int("11")) # False
print(str(10) == "10") # True
print("\n")
print("A: ", ord("A"))
print("a: ",ord("a"))

str1 = "ApPlE"

print(str.upper(str1) > str.lower(str1))
print(str.title(str1) > str1)

"""# ***Iterations***

"""

for number in range(1, 10, 2):  # range(start:initally 0;if set it will include that number, end:excluding the end number, step: how many steps)
  print("fuck you", number + 1, (number + 1) * ".")


# there is a funny thing in python
# for...else -> if the loop finishes without any inturrption
# it will execute the else portion otherwise it wont'
# e.g. 

switch = True
for steps in range(1, 6):
  if switch:
    print("get angry")
    switch = False
  elif not switch:
    print("cool down")
    switch = True

  if steps == 5:
    break
else: # if the "if steps == 5" clause executes, this will not going to execute 
  if switch:
    print("bite me")
  else:
    print("fuck me")

# many of python's complex classes are iterables; such as range, string, list/[],
# 
for str1 in "Hoop that fat ass":
  print(str1)

l = 1
r = 1
t = 0
for ca in range(100):
  t = l + r
  print(t)
  l = r
  r = t

cont = 0
for even in range(2, 10, 2):
  print(even)
  cont += 1
  if(even == 8):
    print(f"We have {cont} even numbers")

"""# ***Functions***"""

from IPython.utils.path import filefind
# while defining a function, we give parameters such as strings, integers, and doubles
def make_me(what):
  print(f"make me {what}")
  file = open("content.txt", "w")
  file.write(f"make me {what}")

def example_of_keyword_argument(steal, bribe, lawsuit, jailtime):
  return f"I will steal {steal} dollars from you after bribing your wife with {bribe} and then file a lawsuit of {lawsuit} dollars and send you to prison"


# when calling the said function we pass along arguments
make_me("a sandwitch")
make_me("a joint")
make_me("squirt")
make_me("cum")

# by default all the parameters of a function are "required"
# parameters can be made optional by setting the optional value
# ALL THE REQUIRED PARAMETERS SHOUDL COME BEFORE THE OPTIONAL PARAMETERS 


def do_rubbish_stuff(val, mul, dec, divide, mul_again=10, plus=1):
  return (((((val * mul) - dec) / divide) * mul_again) + plus)


print(do_rubbish_stuff(55, 1, 5, 5)) # i didn't define the optional values
print(do_rubbish_stuff(55, 1, 5, 5, mul_again=100)) # only defined the 1 optional value
print(do_rubbish_stuff(55, 1, 5, 5, plus=7)) # only defined the 1 optional value

# single "*" is called "xargs" which is exactly like pointer in C/C++
# double "**" is called "xxargs" 


def cal_sum_of_factorial(*list_of_numbers):
  sum = 0;
  for x in list_of_numbers:
    total = 1
    for y in range(1, x+1):
      total *= y
    sum += total

  return sum

print(cal_sum_of_factorial(2,3,5,1))


# double "**" is used to send dictonaries. Key-value pairs of differnt types
def print_info(**person):
  print(person)

print_info(name="Nayeem Mohammad", age="29", original_birthday="Nov 3rd", passport_birthday="Feb 11th", height="5 foot 11 inch")


# python shortcuts for windows


# Home and End key shortcuts

# begining of the line press Home key 
# end of the line press End key
# Ctrl + Home will take to the starting of the file 
# Ctrl + End will take to the end of the file 



# move line upward -> Alt + up arrow
# move line downward -> Alt + down arrow
# copying lines -> Shift + Alt + down arrow/up arrow
# copying lines -> Shift + Alt + down arrow
# copying lines -> Shift + Alt + down arrow
# copying lines -> Shift + Alt + down arrow
# copying lines -> Shift + Alt + down arrow
# copying lines -> Shift + Alt + down arrow
# copying lines -> Shift + Alt + down arrow

def fizz_buzz(input):
  if input % 5 == 0 and input % 3 == 0:
    return "FizzBuzz"
  if input % 5 == 0:
    return "Buzz"
  if input % 3 == 0:
    return "Fizz"
  return input


print(fizz_buzz(5))
print(fizz_buzz(3))
print(fizz_buzz(15))
print(fizz_buzz(30))
print(fizz_buzz(45))
print(fizz_buzz(25))
print(fizz_buzz(26))
print(fizz_buzz(27))
print(fizz_buzz(28))
print(fizz_buzz(29))
print(fizz_buzz(33))
print(fizz_buzz(60))

"""#***Data Structures***

***Lists***
"""

# list()
letters = ["a","z","b","y","c","x"]
tolist = [letters]
matrix = [[1,2],[True, False, True, False],["cat", "bat", "hat", "rat", "mat", "twat"]]

print(matrix)
print(matrix + letters)
print(letters + matrix)


zeros = [0] * 10
numbers = list(range(20))
combine = zeros + numbers
print(combine)
print(len(combine))

print(combine[::2])
print(combine[::-1])

combo1 = tolist + matrix
print(combo1)

print("*************************")
# unpacking

letterz, digits, bools, ats = combo1

print(letterz)
print(digits)
print(bools)
print(ats)

print("*************************")
#to ignore the things that you dont' need to unpack put "*" and create a new list


combo2 = matrix + letters
digits, bools, ats, *rest = combo2
print(digits)
print(ats)
print(rest)

print("*************************")
#looping over lists vs enumerating over lists

for x in combo1:
  print(x)

for x in enumerate(combo1):
  idx, liss = x
  print(type(x))
  print(x, liss)

print("*************************")

#adding 

aarray = ["cat", "dog", "horse", "cow", "chicken"]

aarray.append("crow")
aarray.append("crow")
print(aarray.count("crow"))
print(aarray.count("cr"))
print(aarray)
aarray.sort()
print(aarray)
aarray.sort(reverse=True)
print(aarray)
aarray.insert(3, "squarrel")
print(aarray)
aarray.remove("squarrel")
print(aarray)
del aarray[0:1]
print(aarray)
aarray.clear()

print("*************************")


# a function doesn't take positional argumenmts meaning that 
# it will only take keyword argument.
# bite_me(name="Lana Rohades")

# lambda function

list_item = [
    ("item1", 100),
    ("item2", 50),
    ("item3", 400),
    ("item4", 20),
    ("item5", 500)
]

new_list_item = list_item.copy()


def sort_item(list_item):
  return list_item[1] # will return the price of the item


list_item.sort(key=sort_item)
print(list_item)


list_item.sort(key=sort_item, reverse=True)
print(list_item)


# lambda can be used to do this previous steps much more easily

new_list_item.sort(key=lambda list_item:list_item[1])
print(new_list_item)

prices = list(map(lambda item: item[1], list_item))
print("map usage: ", prices)

prices = list(filter(lambda item: item[1] >= 200, list_item))
print("map usage: ", prices)

# list comprehension 
# mapping and filtering list can also be done using list comprehension 
# template
# [expression for item in items]
# items -> iterable; item -> a single item; expression -> an expression

prices = [val[1] for val in list_item]
print(prices) 

filtered = [item for item in list_item if item[1] >= 200]
print(filtered)

#zip function

l1 = [1,2,3,4,5]
l2 = [10,19,15,25,26,97,22,4,6,5]
l3 = "i will be there for you"

print(list(zip(l2,l3,l1))) # the limiting size is the smallest size

"""***Stack Queue Tuple Array Sets***"""

# stack is also implemented using list
stk = []
stk.append("Lana Rohades")
stk.append("Juila Ann")
stk.append("AJ applegate")
stk.append("Eva Lovia")
stk.append("Kayden Kross")

last_seen = stk.pop()
print(last_seen)
print(stk)

if not stk:
  print(stk[-1])

# queue can also be implemented as list. but the best practice is to use dequeue object

from collections import deque

queue = deque([])
queue.append(1)
queue.append(2)
queue.append(4)
queue.append(163)
queue.append(112)

print(queue)

sorted(queue, reverse=True)


# tuple 
# tuple()
point = 1,
print(type(point))

point = (69,) * 5
print(point)


list1 = [5,6,8,9,12,36]
hlw = tuple(list1)
print(hlw)

hlw = tuple("Hello Mothefukka")
print(hlw)

x = 10
y = 8

x, y = y, x # right side of the eq are tuples and the tuples are being unpacked into x,y; what makes the swap happne

print("x ", x)
print("y ", y)

# Array

from array import array

# its parameter is typecode 
# type Code	C++ Type	Python Type	Minimum Sizes in Bytes
# ‘c’	char	character	1
# ‘b’	signed char	int	1
# ‘B’	unsigned char	int	1
# ‘u’	Py_UNICODE	unicode character	2
# ‘h’	signed short	int	2
# ‘H’	unsigned short	int	2
# ‘i’	signed int	int	2
# ‘I’	unsigned int	long	2
# ‘l’	signed long	int	4
# ‘L’	unsigned long	long	4
# ‘f’	float	float	4
# ‘d’	double	float	8


numbers = array("i", [5,6,8,12,65,7,45,21,45])

# array takes on uniform type, unlike lists you can't mix int with float or string
# will get a TypeError; typecode is there to begin with

# Sets
# set()
numbers = [1,1,1,1,3,4,5,5,6,7,2,8,9,7,6,64,2,2,3]

unique = set(numbers)

unique1 = set([33,33,25,55,56,65,47,41,12,58,963,21,477,512,147,65,14,785,1,85,2,4785,214,7856,69,85,2,58,5,69,5,5,58,43])

print(unique)
print(type(unique))
u = unique.symmetric_difference(unique1)

print(u)
u.add(100)
u.remove(7856)
print(u)

x = {2,3,4}
y = {1,3,5,7,9}
z = {0,2,4,6,8}

# to get union of two sets
print(x | y | z)
# to get intersection
print(x & y)
# to get differences between two sets
print(x - y) 
# to get symmetric difference 
print(x ^ y)


# list() tuple() set()
# Summary 
# lists take third brackets "[]" -> can be modified and can contain duplicates
# tuples take first brackets "()" -> can't be modified
# sets take second brckets "{}" -> can't contain duplicates  -> can't be accessed with index; i.e. it's unordered DS

"""***Dictonaries Generator Expression Unpacking operator***"""

# Dictonaries
# dict()
# key-value pairs

# two ways to instantiate dictonaries
point = {"x" : 1,
         "y" : 2,
         "z" : 3,
         "a" : 4,
         "b" : 5
         }
print(point)

point = dict(x=1, y=100, z = 50, ls="duck")
print(point)

print(point["ls"])
point["ls"] = "fuck"
print(point)
point['ms'] = "me"
point['ns'] = "running"
print(point)

# see if a key exists or not
if "os" in point:
  print("not here")

print(point.get("os", 0)) # without 0, it would've returned None

# del point["os"] # gives keyError
del point["x"]
print(point)

for thing in point:
  print(thing) # giving me keys only

for thing in point:
  print(thing, point[thing]) # giving me key-vlaue pair

for thing, thing_val in point.items():
  print(thing, thing_val) # using unpacking



print("******************************")
print("***Dictonary Comprehension****")
print("******************************")

values = {}

for x in range(5):
  values[x] = x * 2
print(values)


values = {x: x * 2 for x in range(10, 16)}
print(values)

# Generator Expression 
# generator object is a created with "()" like tuple
# it only generates but doesn't store data
# generator expression is an iterable 
# example

from sys import getsizeof

values = (x * 2 for x in range(10000)) # generator object 10K
print('size of generator obj: ', getsizeof(values))

values = (x * 2 for x in range(1000000)) # generator object 1 MIL
print('size of generator obj: ', getsizeof(values))

values = [x * 2 for x in range(1000000)] # list object
print('size of list obj: ', getsizeof(values))


print("******************************")
print("******Unpacking Operator******")
print("******************************")

num1 = [1,2,3,4,5]
print(num1)
print(*num1)

values = [*range(50, 60), *"kiss my ass"]
print(values)


# unpacking dictonaries with two asterics "**"

first = {"x": 1}
second = {"x": 3, "y": 5}
combined = {**first, **second}
print(combined)


# Exercise

sentence = "This is a common interview question" # find the most repeated letter used here

dicto = {}
mx = 0
mx_l = ""

dicto[s1] = 0
dicto[s1] = dicto[s1] + 1
print(dicto)

for l in sentence:
  k = str(l)
  if k == " ":
    continue
  if not dicto.get(k):
    dicto[k] = 1
  else:
    dicto[k] = dicto[k] + 1
    if(dicto[k] > mx):
      mx = dicto[k]
      mx_l = k

print(dicto)
print(mx_l, mx)

print("the solution they gave to the exercise")

from pprint import pprint

sentence = "This is a common interview question" # find the most repeated letter used here

char_frequency = {}
for char in sentence:
  if char in char_frequency:
    char_frequency[char] += 1
  else: 
    char_frequency[char] = 1

pprint(char_frequency, width=1)

char_frequency_sorted = sorted(char_frequency.items(), 
                               key=lambda kv: kv[1], 
                               reverse=True)
print(char_frequency_sorted[0])



























